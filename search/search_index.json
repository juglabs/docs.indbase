{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"INDBASE.COM World Class Platform-as-a-Service Offerings Managed Cloud Hosting Service Quick, Hassale free, Economic Deployment Built in Observability, Scalability, Reliability, Security MADE WITH LOVE IN","title":"Home"},{"location":"#indbasecom","text":"","title":"INDBASE.COM"},{"location":"#world-class-platform-as-a-service","text":"","title":"World Class Platform-as-a-Service"},{"location":"#offerings","text":"Managed Cloud Hosting Service Quick, Hassale free, Economic Deployment Built in Observability, Scalability, Reliability, Security MADE WITH LOVE IN","title":"Offerings"},{"location":"about/","text":"About Indbase.com is a Platform as a Service which takes away the headache of managing the Infrastructure for your Software. Indbase.com offers unparalled experience in hosting your applications - Easy, Fast, Cheap, Reliable, Secure, Observable! Indbase.com is built on the strong principles of Cloud native comptuing. Principles like Scalability, Reliability, Observability, Manageability are built-in. It's quintessentially a TWELVE-FACTOR App","title":"About"},{"location":"about/#about","text":"Indbase.com is a Platform as a Service which takes away the headache of managing the Infrastructure for your Software. Indbase.com offers unparalled experience in hosting your applications - Easy, Fast, Cheap, Reliable, Secure, Observable! Indbase.com is built on the strong principles of Cloud native comptuing. Principles like Scalability, Reliability, Observability, Manageability are built-in. It's quintessentially a TWELVE-FACTOR App","title":"About"},{"location":"paas/architecture/architecture/","text":"Different Micro Services Upload Service Build Service Deploy Service","title":"Architecture"},{"location":"paas/architecture/architecture/#different-micro-services","text":"","title":"Different Micro Services"},{"location":"paas/architecture/architecture/#upload-service","text":"","title":"Upload Service"},{"location":"paas/architecture/architecture/#build-service","text":"","title":"Build Service"},{"location":"paas/architecture/architecture/#deploy-service","text":"","title":"Deploy Service"},{"location":"paas/basics/paas-basics/","text":"PaaS Gyaan When you're tiny, margins should not be what you focus on. When you'are tiny, you should be focused on creating customer value. Bill Gates said something along the lines of \u201cA platform is when the customer\u2019s value exceeds the creator\u2019s value.\u201d The person who created the platform gets something back out of it, they get financial gain or whatever, but the people who build on top of it get so much more value out of what they\u2019ve built. And that\u2019s a platform. Multi-tenant Kubernetes clusters at scale, at their scale, for a lot of customers\u2026 Because that is something that has been really, really hard for even a single company.","title":"Basics"},{"location":"paas/basics/paas-basics/#paas-gyaan","text":"When you're tiny, margins should not be what you focus on. When you'are tiny, you should be focused on creating customer value. Bill Gates said something along the lines of \u201cA platform is when the customer\u2019s value exceeds the creator\u2019s value.\u201d The person who created the platform gets something back out of it, they get financial gain or whatever, but the people who build on top of it get so much more value out of what they\u2019ve built. And that\u2019s a platform. Multi-tenant Kubernetes clusters at scale, at their scale, for a lot of customers\u2026 Because that is something that has been really, really hard for even a single company.","title":"PaaS Gyaan"},{"location":"paas/issues/paas-issues/","text":"Issues to keep track Problems with Cloud Service Providers - AWS, GCP etc Stripe in its initial days was engaging 20% of their engineering team on managing AWS infrastructure. Its about the same in other companies also Stripe back in 2016 was still not using Kubernetes AWS is like, look we give you these legos, you build whatever you want! But the QUESTION is, once these applications on PaaS scale, it begins HARD TO DEBUG. So how do you deal with that? Your platform should expose right kind of primitives, but it doesn't have to expose all fo them at the same time, and all of them in the same way. Platform should have PRIVATE NETWORKING built in, SERVICE DISCOVERY built in Every application on the platform gets both a public address and private address - databases, managed data stores etc Network Isolation as a feature, isolate development/staging/production environments from each other from a network standpoint of view with a single click Ultimately it really comes down to being INCREDIBLY CLOSE to your customers who are scaling on the platform - AWS-NETFLIX analogy User Experience Lot of IN-PRODUCT GUIDANCE Information architecture work Lot of design, UI/UX Lot of sensible defaults Customer feedback Good logs, Good Documents, Good Error Messageas are key Managing Kubernetes Kubernetes does a good job with container orchestration Problem with K8 - surface area of K8 is massive - even to do a simple thing you have to understand 10 different concepts Give people the flexibility of Kubernetes without having to understand things Things to take care - Security As your product becomes popular, DDoS attacks become common - and not just at the HTTP layer, but at L4 as well, at the TCP layer So if you are dealing with bare metal, then you have to work about L3,L4, application level attacks So RENDER didn't do bare metal, they use AWS, GCP, CloudFlare because they've dealt with these problems before","title":"Issues"},{"location":"paas/issues/paas-issues/#issues-to-keep-track","text":"","title":"Issues to keep track"},{"location":"paas/issues/paas-issues/#problems-with-cloud-service-providers-aws-gcp-etc","text":"Stripe in its initial days was engaging 20% of their engineering team on managing AWS infrastructure. Its about the same in other companies also Stripe back in 2016 was still not using Kubernetes AWS is like, look we give you these legos, you build whatever you want! But the QUESTION is, once these applications on PaaS scale, it begins HARD TO DEBUG. So how do you deal with that? Your platform should expose right kind of primitives, but it doesn't have to expose all fo them at the same time, and all of them in the same way. Platform should have PRIVATE NETWORKING built in, SERVICE DISCOVERY built in Every application on the platform gets both a public address and private address - databases, managed data stores etc Network Isolation as a feature, isolate development/staging/production environments from each other from a network standpoint of view with a single click Ultimately it really comes down to being INCREDIBLY CLOSE to your customers who are scaling on the platform - AWS-NETFLIX analogy","title":"Problems with Cloud Service Providers - AWS, GCP etc"},{"location":"paas/issues/paas-issues/#user-experience","text":"Lot of IN-PRODUCT GUIDANCE Information architecture work Lot of design, UI/UX Lot of sensible defaults Customer feedback Good logs, Good Documents, Good Error Messageas are key","title":"User Experience"},{"location":"paas/issues/paas-issues/#managing-kubernetes","text":"Kubernetes does a good job with container orchestration Problem with K8 - surface area of K8 is massive - even to do a simple thing you have to understand 10 different concepts Give people the flexibility of Kubernetes without having to understand things","title":"Managing Kubernetes"},{"location":"paas/issues/paas-issues/#things-to-take-care-security","text":"As your product becomes popular, DDoS attacks become common - and not just at the HTTP layer, but at L4 as well, at the TCP layer So if you are dealing with bare metal, then you have to work about L3,L4, application level attacks So RENDER didn't do bare metal, they use AWS, GCP, CloudFlare because they've dealt with these problems before","title":"Things to take care - Security"},{"location":"paas/services/build-service/","text":"Build Service Different Build Options Buildpacks Today 25-11-2024, tried buildpacks - Software that transforms the application source code into runnable artifacts by analyzing the code and determining the best way to build it. You need to select the optimum \"builder\" to build the image - available options include Paketo Buildpacks, Google Cloud buildpacks, Heroku Buildpacks, Cloud Foundry etc. Paketo Buildpacks led to error realted to Node.js version. Even with error, it took some 5 minutes to build and throw error. Then used Google Cloud Buildpacks - it worked ust fine with around 6 minutes time from build command to successful image build. 6 minutes is quite a lot in todays time. (Guess it obviously depends on the Server configs - the case above being Macbook Air with M2 processor) We are talking of the order of seconds. Your end to end deployment - from selecting Git Repo to deployment- should be done say within 2 minutes. That marks a significant improvement in the customer user experience vis-a-vis verce, netlify, heroku etc. Fly.io comes close. The aim is to beat all of them. World Class should mean that. You should be the best in the business. Builder Base OS Supported languages Use case Paketo Buildpacks Ubuntu Wide variety General Purpose, ligthweight Google Cloud Bldp Debain Java, Node, Go etc Optimized for GCP Heroku Buildpacks Ubuntu Heroku supp lang Heroku apps, simplicity Cloud Foundry Ubuntu Java, PHP, Go etc Clodu Foundry compatibility Red Hat UBI Bldp RHEL Enterprise grade Openshift, enterprise env Interestingly, Fly.io does little differently. They do images but not Docker! They unwrap image layer by layer while running container- something of that sort? Fly.io's build service works like this: First it checks if there is a Dockerfile along with the code, so that image can be built right away without the help of Buildpacks If no Dockerfile present, Buildpacks takes over and auto scans the code, detect language and framework, download the dependencies, build image If readily built image is provided, then its used to deploy the application. In the interest of time and to avoid depending on external software like Buildpacks to build the application, it's wiser to write your own auto scan code -> prepare Dockerfile -> Build image. And it's not that complicated. Just scan for the relevant config files like package.json (react), gemfile(Ruby), index.js or app.js(react), requirements.txt (Python), composer.json(for PHP/Laravel/Symfony), pom.xml or build.gradle (Java), packages.config (.NET) etc Questions How to increase the Build speed? How to minimize the Build Image size? Because buildpacks image sizes are in general large. How to make Build process reliable? What are the various options? How to manage secrets during image build? How to add Volumes, Databases, Storage to the app?","title":"Services"},{"location":"paas/services/build-service/#build-service","text":"","title":"Build Service"},{"location":"paas/services/build-service/#different-build-options","text":"","title":"Different Build Options"},{"location":"paas/services/build-service/#buildpacks","text":"Today 25-11-2024, tried buildpacks - Software that transforms the application source code into runnable artifacts by analyzing the code and determining the best way to build it. You need to select the optimum \"builder\" to build the image - available options include Paketo Buildpacks, Google Cloud buildpacks, Heroku Buildpacks, Cloud Foundry etc. Paketo Buildpacks led to error realted to Node.js version. Even with error, it took some 5 minutes to build and throw error. Then used Google Cloud Buildpacks - it worked ust fine with around 6 minutes time from build command to successful image build. 6 minutes is quite a lot in todays time. (Guess it obviously depends on the Server configs - the case above being Macbook Air with M2 processor) We are talking of the order of seconds. Your end to end deployment - from selecting Git Repo to deployment- should be done say within 2 minutes. That marks a significant improvement in the customer user experience vis-a-vis verce, netlify, heroku etc. Fly.io comes close. The aim is to beat all of them. World Class should mean that. You should be the best in the business. Builder Base OS Supported languages Use case Paketo Buildpacks Ubuntu Wide variety General Purpose, ligthweight Google Cloud Bldp Debain Java, Node, Go etc Optimized for GCP Heroku Buildpacks Ubuntu Heroku supp lang Heroku apps, simplicity Cloud Foundry Ubuntu Java, PHP, Go etc Clodu Foundry compatibility Red Hat UBI Bldp RHEL Enterprise grade Openshift, enterprise env Interestingly, Fly.io does little differently. They do images but not Docker! They unwrap image layer by layer while running container- something of that sort? Fly.io's build service works like this: First it checks if there is a Dockerfile along with the code, so that image can be built right away without the help of Buildpacks If no Dockerfile present, Buildpacks takes over and auto scans the code, detect language and framework, download the dependencies, build image If readily built image is provided, then its used to deploy the application. In the interest of time and to avoid depending on external software like Buildpacks to build the application, it's wiser to write your own auto scan code -> prepare Dockerfile -> Build image. And it's not that complicated. Just scan for the relevant config files like package.json (react), gemfile(Ruby), index.js or app.js(react), requirements.txt (Python), composer.json(for PHP/Laravel/Symfony), pom.xml or build.gradle (Java), packages.config (.NET) etc","title":"Buildpacks"},{"location":"paas/services/build-service/#questions","text":"How to increase the Build speed? How to minimize the Build Image size? Because buildpacks image sizes are in general large. How to make Build process reliable? What are the various options? How to manage secrets during image build? How to add Volumes, Databases, Storage to the app?","title":"Questions"},{"location":"paas/url/url/","text":"","title":"Url"},{"location":"tools/tools/","text":"Useful Tools Viper Configuration management tool for Golang by spf13 Cobra Golang framework for CLI apps","title":"Tools"},{"location":"tools/tools/#useful-tools","text":"","title":"Useful Tools"},{"location":"tools/tools/#viper","text":"Configuration management tool for Golang by spf13","title":"Viper"},{"location":"tools/tools/#cobra","text":"Golang framework for CLI apps","title":"Cobra"}]}